---
title:  Mixins
---

### Motivation

Almost from start of the development Ü has reach metaprogramming mechanisms - templates, `static_if`, `enable_if`, type inspection via `typeinfo` and powerful (but limited) compile-time code execution.
But even with such possibilities Ü had some fundamental limitations, which limits metaprogramming needs. Some of them:

* Reference and mutability modifiers of function parameters, return values, struct fields, variables were fixed, even in template code. It wasn't possible for example to declare a field with its mutability depending on template args. But some of these limitations were possible to get around via type templates overloading or `enable_if`.
* It wasn't possible to create a template method or any function with number of parameters calculated in compilation time. It was possible to create many overloads with different number of parameters, but it wasn't too practical.
* It wasn't possible to create a struct with variable number of fields. All fields were hardcoded even in templates, no number of files and their names may be configured.
* Name lookup was fixed. It wasn't possible (for example) to call a method or to access a field of a struct if its name isn't statically known.

These limitations were not so painful, but sometimes forced to write code differently or create too much boilerplate.
Because of that i searched for a solution, which allows to solve all these problems.


### In search for a solution

Initially i thought to make reference/mutability modifiers syntax more complex - add some `constexpr` parameter for them in order to make mutability/reference modifier conditional.
This might work, but it seems to be too complicated to implement and too boilerplate to use.

Also i have thoughts to implement (somehow) template functions with variable number of parameters.
But this idea is also hard to implement and use.

All these solutions are too partial and doesn't solve all problems.
Thus i decided to find a perfect solution - which allows to solve all of them.


### The most stupid and powerful solution

I decided to investigate, how other programming languages solve such inflexibility.
I have found, that language _Zig_ uses some sort of compile-time code generation for polymorphism, where languages like C++ and Rust use templates.
_D_ language also provides a mechanism to generate code from compile-time generated string.
This mechanism is named _mixin_.
After some thinking i decided, that this solution is almost perfect and is worth to implement it.


### Mixins basics

Generally mixins work pretty simple.
Mixin expression is evaluated (in compile time) and given text is parsed as normal Ü program or its fragment.
Than parsed syntax elements are added in place of mixin usage.

Examples:

```
mixin( "fn Foo() : i32 { return 42; }" ); // Add a method via mixin.

struct S
{
    mixin( fields ); // Add struct fields using mixin.
    auto& fields= "i32 x; f32 y;";
}

fn Bar()
{
    var S mut s= zero_init;
    mixin( "s.x= 1; x.y= 0.5f;" ); // Add mixin block elements.
    auto sum= f32(mixin("s.x")) + mixin("s.y"); // Use mixins in expression context.
}
```

But it was not so trivial.
For mixins in namespace and class context it was needed to implement mixins expansion as separate compilation step - between names table preparation and other frontend logic.
For mixins in block and expression context it's simpler - result syntax elements may be used directly to build block elements or an expression.
Additional complication adds necessity to parse mixin text properly, using macros available only in the file, where this mixin is used.