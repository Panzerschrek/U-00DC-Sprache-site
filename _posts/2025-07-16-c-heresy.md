---
title: Pure C heresy
---

## Pure C heresy

I noticed recently a strange trend in low-level programming.
This trend consists of rejecting of C++ and similar languages (like Rust) in favor of pure C.
It isn't common, but it has significant number of followers, some of them are pretty prominent.

In this article I want to oppose this trend.

Why exactly I name it heresy?
This trend reminds me one particular heresy in the history of the russian orthodoxy - [Heresy of the Judaizers](https://en.wikipedia.org/wiki/Heresy_of_the_Judaizers).
Followers of this heresy rejected some christianity elements in favor of old-style Judaism practices.
In the same way followers of C heresy reject innovations of C++.


### C++ as better C

Even if heretics find C++ overcompicated and not so good, C++ still can offer a lot of neat features usable in old C-style programming.
This includes:

* C++ has stronger type system. C++ doesn't allow by default conversion between unrelated pointer types, doesn't allow to violate mutability so easily.
  Additionaly it may prevent some unsafe numeric type conversions, if compilation options like `-Wconversion` are used.
* C++ structs don't require prefixing struct name with `struct` keyword when using it, nor they require adding a typedef for them.
* C++ provides a better alternative for defines for constants - constexpr variables.
  They fulfill the same purpose as simple literal defines, but are generally safer (no preprocessor mess is involved) and remain as fast as define constants.
* C++ template functions provide better alternative for C function-like macros.
  A good example are macros like `min` and `max`, which may be replaced with such template function.
* C++ has namespaces, which allows library authors to place their code in a specific namespace, which is better relative to C approach with manual prefix adding for each function/type.
* C++ provides scoped enums, which allows to avoid adding prefixes for enumerators to ensure their uniqueness.
  Also scoped enums prevent mistakes where inproper enum type is used.


### C++ beyond better C

* C++ has destructors.
  I found this the core feature of the whole language and overall one of the most significant programming inventions.
  Destructpors allow to implement RAII semantics, which greatly simplifies code compared to manual calls to cleanup functions (memory free, file close, etc.) like in C code.
  A lot of useful concepts are possible only because of destructors - basic heap-allocated containers like `std::string` and `std::vector`, smart pointers (`std::unique_ptr`, `std::shared_ptr`), `std::thread` class, etc.
* C++ has type templates, which allows to implement abstract data structures, without messy preprocessor, which is used by some C heretics as poor's man replacement for this.
* C++ allows operators overloaidng, which greatly simplifies some code.
  Especially it's useful for `=` operators - it's much simple to write `string_a= string_b;`, compared to C-style function call like `copy_string( string_a, string_b );`.
  Arithmetic operators overloading is also useful, especially for things like vectors and matrices.
* C++ supports dynamic type-safe polymorphism via inheritance.
  It's much better compared to `void*` pointers usage, like in C.
  C++ is often critisized, because it's possible to create big inheritance hierarchies, but this criticism isn't correct - the language itself doesn't force one to create such hierarchies, one don't need to use them, if it isn't really necessary.


### Ãœ as much better C++
