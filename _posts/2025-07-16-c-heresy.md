---
title: Pure C heresy
---

## Pure C heresy

I noticed recently a strange trend in low-level programming.
This trend consists of rejecting of C++ and similar languages (like Rust) in favor of pure C.
It isn't common, but it has significant number of followers, some of them are pretty prominent.

In this article I want to oppose this trend.

Why exactly I name it heresy?
This trend reminds me one particular heresy in the history of the russian orthodoxy - [Heresy of the Judaizers](https://en.wikipedia.org/wiki/Heresy_of_the_Judaizers).
Followers of this heresy rejected some christianity elements in favor of old-style Judaism practices.
In the same way followers of the pure C heresy reject innovations of C++.


### C++ as better C

Even if pure C heretics find C++ overcompicated and not so good, C++ still can offer a lot of neat features usable in old C-style programming.
This includes:

* C++ has stronger type system. C++ doesn't allow by default conversion between unrelated pointer types, doesn't allow to violate mutability so easily.
  Additionaly it may prevent some unsafe numeric type conversions, if compilation options like `-Wconversion` are used.
* C++ structs don't require prefixing struct name with `struct` keyword when using it, nor they require adding a typedef for them.
* C++ provides a better alternative for defines for constants - constexpr variables.
  They fulfill the same purpose as simple literal defines, but are generally safer (no preprocessor mess is involved) and result code is as fast as with define constants.
* C++ template functions provide better alternative for C function-like macros.
  A good example are macros like `min` and `max`, which may be replaced with such template function.
* C++ has namespaces, which allows library authors to place their code in a specific namespace, which is better relative to C approach with manual prefix adding for each function/type.
* C++ provides scoped enums, which allows to avoid adding prefixes for enumerators to ensure their uniqueness.
  Also scoped enums prevent mistakes where inproper enum type is used.

So, even for C purists there is no reason not to use features listed above.
Earlier (in 90s) C++ wasn't so common and maybe there were problems finding a working C++ compiler for target platform.
But nowdays C++ compilers like *GCC* or *clang* support a lot of systems/CPU architectures, so that it's extremely unlikely, that they can't be used for compiling for some specific platform.
Even if it happens, generally it's better to try adopting *clang* or *GCC* for such a platform, rather than writing a whole program using plain C.

Sometimes pure C heretics claim, that C has less longevity issues compared to C++.
But I doubt it's true.
Both languages avoid breaking backward compatibility and thus it's unlikely, that code written for earlier standards can't run on newer standards.


### C++ beyond better C

I think that C++ is much more than better C.
It has several innovations, which make it to completely new and much better language.
This includes:

* C++ has destructors.
  I found destructors the core feature of the whole language and overall one of the most significant programming inventions.
  Destructpors allow to implement RAII semantics, which greatly simplifies code compared to manual calls to cleanup functions (memory free, file close, etc.) like in C code.
  A lot of useful concepts are possible only because of destructors - basic heap-allocated containers like `std::string` and `std::vector`, smart pointers (`std::unique_ptr`, `std::shared_ptr`), `std::thread` class, etc.
* C++ has type templates, which allows to implement abstract data structures, without messy preprocessor, which is usually used by pure C heretics as poor's man replacement for this.
* C++ allows operators overloaidng, which greatly simplifies some code.
  Especially it's useful for `=` operators - it's much simple to write `string_a= string_b;`, compared to C-style function call like `copy_string( string_a, string_b );`.
  Arithmetic operators overloading is also useful, especially for things like vectors and matrices.
* C++ supports dynamic type-safe polymorphism via inheritance.
  It's much better compared to `void*` pointers usage, like in C.
  C++ is often critisized, because it's possible to create big inheritance hierarchies, but this criticism isn't correct - the language itself doesn't force one to create such hierarchies, one don't need to use them, if it isn't really necessary.


### C++ own sins

I must admit, that some C++ criticism, mentioned by pure C heretics, is correct.
C++ has a long path of development and this it wasn't always straigh.

In initial stages of development C++ was heavely affected by OOP ideas in worste form.
Inheritance was used too much and thus multiple inheritance and virtual inheritance were added into the language.
These features are now considered to be harmful and they are used rarely.
But they still remain with us (for backward compatibility reasons).
Nowdays it's perffered to avoid using inheritance, if it isn't strictly necessary and even if it's used, it's limited for simple cases like interface-implementation, for other purposes composition or `std::variant` are used.

Excepthions are also a great C++ sin.
As they were initially introduced, they were problematic.
Then ``throw`` notations were added to fix them.
But this wasn't enough and thus ``nothrow`` came.

But C++ exceptions are still fundamentally wrong.
They violate one of the most significant C++ design principles - don't pay for what you don't use.
Even so-called zero-cost exception implementations (on happy path) aren't really zero-cost, since they affect optimizations, because of possible unwinding.
Also they introduce additional executable bloat - for unwinding code.

They are also problematic, since it's allowed to pass exceptions silently to the caller, in hope if caller can handle them.
But this usually doesn't happen and thus exceptions are caught in ``main`` functions or aren't caught at all.

All these OOP ideas and exceptions may be considered to be another sort of heresy in C++.
It's fine to name it Java-heresy, since Java is practically OOP cancer in terminal stage.


### Ü as much better C++

Ü tries to preserve good element of C++, but it rejects its sins.
Also it doesn't contain unsafe elements, which C++ have from C, at least in such unsafe form.

Ü has destructors, operators overloading, type templates, function templates, namespaces.

Ü has inheritance, but it's limited - no multiple inheritance is possible, except implementing more than one interface.
Also Ü has clear spearation between polymorph and non-polymorph classes, which eliminates problems, which C++ have, like with missing virtual destructor.

Ü has no exceptions and will never have them.
There is no special mechanism for handling so-called "errors".
Errors are just considered to be one of possible outcomes and thus are handled exactly like other values.

Ü has clear separation between safe and unsafe code, unlike C or C++, where all code is practically unsafe.
But the most important Ü feature is its reference checking mechanism, which eliminates a lot of errors in compilation stage.
