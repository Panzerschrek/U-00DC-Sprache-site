---
title: Pure C heresy
---

## Pure C heresy

Recently I noticed a strange trend in low-level programming circles.
It consists of rejecting of C++ and similar languages (like Rust) in favor of pure C.
It isn't common, but it has significant number of followers, some of them are pretty prominent.
Especially it's common among game programmers, system programmers and other people, who need to use proper programming languages (not a VM-based bullshit).

In this article I want to oppose this trend.

I name this trend pure C heresy.
But why heresy?
This trend reminds me one particular heresy in the history of the russian orthodoxy - [Heresy of the Judaizers](https://en.wikipedia.org/wiki/Heresy_of_the_Judaizers).
Followers of this heresy rejected some christianity elements in favor of old-style Judaism practices.
In the same way followers of the pure C heresy reject innovations of C++.


### Notable examples of the pure C heresy

Eskil Steenberg seems to be one of typical examples of pure C heretic.
In [this video](https://www.youtube.com/watch?v=443UNeGrFoM) it explains, why and how it writes C.
In other talks/articles he also advocates pure C usage.

Linus Torvalds is a notable pure C heretic.
His criticism of C++ is focused on this language to be too complex, which don't allow one to achieve good code quality and reasonable performance.
Also he criticizes C+++ exceptions and as he calls it "memory allocations behind your back".

[Zig](https://ziglang.org/) programming language is a good example of pure C heresy.
Stritly speaking it's not C, but this language rejects C++ innovations and claims to be better C.
His author Andrew Kelly is considered to be pure C heretic.

Go programming language is also a good example of pure C heresy, but somewhat evolved into a new language.
It tries to be as simple as C, but with addition of some really necessary elements, like built-in arrays, strings, hash-tables.
But it rejects a lot of C++ innovations, including templates.
Recently generics were added, but it's too late, this should be done from the start.


### C++ as better C

Even if pure C heretics find C++ overcompicated and not so good, C++ still can offer a lot of neat features usable in old C-style programming.
This includes:

* C++ has stronger type system. C++ doesn't allow by default conversion between unrelated pointer types, doesn't allow to violate mutability so easily.
  Additionaly it may prevent some unsafe numeric type conversions, if compilation options like `-Wconversion` are used.
* C++ structs don't require prefixing struct name with `struct` keyword when using it, nor they require adding a typedef for them.
* C++ provides a better alternative for defines for constants - constexpr variables.
  They fulfill the same purpose as simple literal defines, but are generally safer (no preprocessor mess is involved) and result code is as fast as with define constants.
* C++ template functions provide better alternative for C function-like macros, which are generally problematic.
  A good example are macros like `min` and `max`, which may be replaced with such template function.
* C++ has namespaces, which allows library authors to place their code in a specific namespace, which is better relative to C approach with manual prefix adding for each function/type.
* C++ provides scoped enums, which allows to avoid adding prefixes for enumerators to ensure their uniqueness.
  Also scoped enums prevent mistakes where inproper enum type is used.

So, even for C purists there is no reason not to use features listed above.
Earlier (in 90s) C++ wasn't so common and maybe there were problems finding a working C++ compiler for some particular target platform.
But nowdays C++ compilers like *GCC* or *clang* support a lot of systems/CPU architectures, so that it's extremely unlikely, that they can't be used for compiling for some specific platform.
Even if it happens, generally it's better at least to try adopting *clang* or *GCC* for such a platform, rather than writing a whole program using plain C.

Sometimes pure C heretics claim, that C has less longevity issues compared to C++.
But I doubt it's true.
Both languages avoid breaking backward compatibility and thus it's unlikely, that code written for earlier standards can't run on newer standards.
And even if something breaks in C++ code with a newer compiler version, it's not an unique C++ problem, C code can be broken in similar cases too.


### C++ beyond better C

I think that C++ is much more than better C.
It has several innovations, which make it to completely new and much better language.
This includes:

* C++ has destructors.
  I found destructors the core feature of the whole language and overall one of the most significant programming inventions.
  Destructpors allow to implement RAII semantics, which greatly simplifies code compared to manual calls to cleanup functions (memory free, file close, etc.) like in C code.
  A lot of useful concepts are possible only because of destructors - basic heap-allocated containers like `std::string` and `std::vector`, smart pointers (`std::unique_ptr`, `std::shared_ptr`), `std::thread` class, etc.
* C++ has type templates, which allows to implement abstract data structures, without messy preprocessor, which is usually used by pure C heretics as poor's man replacement for this.
* C++ allows operators overloaidng, which greatly simplifies some code.
  Especially it's useful for `=` operators - it's much simple to write `string_a= string_b;`, compared to C-style function call like `copy_string( string_a, string_b );`.
  Arithmetic operators overloading is also useful, especially for things like vectors and matrices.
* C++ supports dynamic type-safe polymorphism via inheritance.
  It's much better compared to `void*` pointers usage, like in C.
  C++ is often critisized, because it's possible to create big inheritance hierarchies, but this criticism isn't correct - the language itself doesn't force one to create such hierarchies, one don't need to use them, if it isn't really necessary.
* C++ has references, which are a good addition to C pointers.
  They require no syntax for taking reference/dereferencing, they are always non-null.

Pure C heretics greatly reduce their productivity by rejecting use all these neat elements of C++.
When an average C++ programmer works on actual problem solving, pure C heretics write boilerplate code again and again, occasionally trying to implement in C something resembling C++ features.


### C++ own sins

I must admit, that some C++ criticism, mentioned by pure C heretics, is correct.
C++ has a long path of development behind it and this path wasn't always straigh.

In initial stages of development C++ was heavely affected by OOP ideas in their worst form.
Inheritance was used too much and thus multiple inheritance and even virtual inheritance were added into the language.
These features are now considered to be harmful and they are used rarely.
But they still remain with us (for backward compatibility reasons).
Nowdays it's preffered to avoid using inheritance, if it isn't strictly necessary and even if it's used, it's limited for simple cases like interface-implementation, for other purposes composition or `std::variant` are used.

Excepthions are also a great C++ sin.
As they were initially introduced, they were problematic.
Then ``throw`` notations were added to fix them.
But this wasn't enough and thus ``nothrow`` came.

But C++ exceptions are still fundamentally wrong.
They violate one of the most significant C++ design principles - don't pay for what you don't use.
Even so-called zero-cost exception implementations (on happy path) aren't really zero-cost, since they affect optimizations, because of possible unwinding.
Also they introduce additional executable bloat - for unwinding code.

They are also problematic, since it's allowed to pass exceptions silently to the caller, in hope if caller can handle them.
But this usually doesn't happen and thus exceptions are caught in ``main`` functions or aren't caught at all.

All these OOP ideas and exceptions may be considered to be another sort of heresy in C++.
It's fine to name it Java-heresy, since Java is practically OOP cancer in terminal stage.


### Ü as much better C++

Ü tries to preserve good elements of C++, but it rejects its sins.
Also it doesn't contain many elements, which C++ have from C, which are considered to be harmful, at least in such unsafe form.

Ü has destructors, operators overloading, type templates, function templates, namespaces - all neat additions of C++.

Ü has inheritance, but it's limited - no multiple inheritance is possible, except implementing more than one interface.
Also Ü has clear spearation between polymorph and non-polymorph classes, which eliminates problems, which C++ have, like with missing virtual destructor.

Ü has no exceptions and will never have them.
There is no special mechanism for handling so-called "errors".
Errors are just considered to be one of possible outcomes and thus are handled exactly like other values.

Ü has clear separation between safe and unsafe code, unlike C or C++, where all code is practically unsafe.
But the most important Ü feature is its reference checking mechanism, which in combination of safe/unsafe code separation eliminates a lot of errors in compilation stage.
What in often C++ is runtime crash (if one has luck to catch such crash in debugging) is compilation error in Ü.


## A couple of words about Rust

Rust is generally a good C++ seccessor language.
It provides safety (as Ü does) and just like C++ has a lot of neat features.
Unfortunately it isn't ideal.

First, it has no such nice feature of C++ like references.
What is called references in Rust are just glorified pointers - they can be re-assigned and require additional boilerplate for taking reference/dereferencing.
Why it was done is unclear for me.
Perhaps some pure C heretics affected this design decision.

Second, it is heavily focused on traits.
They add extra boilerplate without adding much, C++ has duck-typing instead and it works well.
Also dynamic polymorphism in Rust is implemented atop of traits, which is somewhat strange, since runtime trait objects are limited in comparison to compile-time traits.

I still think Rust is a good language, moving towards right ideas.
But it's still flawed, that's why I develop Ü.


### Conclusion

I hope, that pure C heresy will be defeated - sooner or later.
I don't think we require inquisition to do this, but some sort of council (in terms of christianic councils) may be required, where this heresy should be condemned.
Sunch council may take place in form of a programming conference, for example.

Heresiarchs of this heresy require no punishment, I think, their ideas became at the end irrelevant.
Perhaps some of them can abandone this herecy.
