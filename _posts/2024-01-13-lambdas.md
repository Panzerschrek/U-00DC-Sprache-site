---
title:  Lambdas are here!
---

Recently i added lambdas into Ü.
This article describes motivation for that and how lambdas in Ü work.


### Motivation

There are functions in standard library (and not only in it) with a parameter of some function-like type (function pointer, functional object).
Examples of such functions - `ust::sort` - with comparator function, `thread` class constructor - with thread entry function.
Also possible functions like search with given predicate, iterators with filter/mapping functions, etc.

It was already possible to use such functions - by passing a function pointer or an instance of class with overloaded `()` operator.
But sometimes such approach is too verbose.
It's unlikely that such function/functional class are used anywhere also, so, creating them only for a single usage seems to be overkill.
Another problem of such approach is that functions and classes are defined in global space, not where they are used, that decreases (sometimes) readability and code locality.


### Lambdas as solution

The solution of the problem described above is obvious - add some sort of anonymous functions, defined directly at usage place.
Such functions are named _lambdas_.

A simpliest lambda looks like this:

```
fn SortInts( ust::array_view_imut</i32/> ints )
{
	ust::sort(
		ints,
		lambda( i32 x, i32 y ) : bool { return x < y; } );
}

```

A lambda is defined with usage of `lambda` keyword and following paramters and return value description.

The result of a `lambda` expression is an object of some class generated by the compiler, which has overloaded `()` operator, created from specified description and body.
Because of overloaded `()` such object may be called like a function.


### Captures

It is a good improvement to have local anonymous functions.
But it is not enough.
Sometimes a functional object needs to have some internal state and not to be a (almost) pure function with result depending only on provided arguments.
In order to support such necessity lambdas in Ü may capture local variables and function arguments from a surrounding context.

A lambda with `[=]` captures all such variables that are used inside it by making a copy.

```
// TODO - example

```

A lambda with `[&]` captures all such variables that are used inside it by making a reference.

```
// TODO - example
```

It's even possible to capture mutable references to surrounding variables and change them in a lambda.

```
// TODO - example
```

Captured variables/references become lambda fields (reference fields for captured references).
During lambda object construction such fields are properly initialized.

```
```

For captured values copy constructor is called during lambda construction, or an error is produced is it's not possible.


### Explicit captures


Sometimes it is necessary for better readability to specify captured variables explicitly.
It's possible via capture list.
Variables needed to be captured are listed here, prefixed with `&` if they are needed to be captured by reference.

```
// TODO - example
```

One of the advantages of the usage of capture list is possibility to capture in the same lambda both values and references.

```
// TODO - example
```


### Capture expressions

Yet another way of capturing variables is to specify an initializer expression for a name in a capture list.
If such expression exists, its result will be captured instead of a variable with the same name from the surrounding context.

```
// TODO - example
```

The main advantage of such expression is to possibility to move value into lambda object.
it is useful if copying is too expensive or if an object is not copyable at all.


### Lambda this

``this` in lambdas is inaccessible by the programmer.
It is so in oreder to avoid confusion with possible `this` from the surrounding context.

There is possibility to specify lambda `this` mutability and even create lambdas with `byval` this.

```
// TODO - example
```

It is even possible to move captured variables in `byval mut` this, which is (for now) not allowed in `byval mut this` methods of non-lambda structs and classes.


### Internal compiler workflow for lambdas

The compiler performs for lambdas preprocessing step - in order to find captured external variables.
This is basically a compilation of a lambda function, but later such function is removed.

After the preprocessing actual lambda function building is triggered.

Because of preprocessing it's possible to calculate reference notation for lambdas automatically, no need to specify it explicitly.
And it's even not possible to do so, because one may need to know exact reference notation for the result lambda class, which is practically hard, since result class layout and reference notation isn't so trivially predicted by a programmer.


The approach with preprocessing has one significant downside - it doesn't allow to implement template lambdas.
So, if it is necessary, regular functional classes shoudl be used instead, where operator `()` may be template.


### Conclusion

Lambdas do not add something fundamental into the language, but they allow to improve code readability, sometimes significantly.

A lot of other programming languages have lambdas or something similar, for programmers who have experience with such languages it will be easy to use lambdas in Ü.
Perhaps this may make transition to Ü smoother.


### Possible further work

Lambdas for now can't be coroutines - generators and async functions.
And i do not know, whatever there should be such lambdas.

It seems for me to be better to have some similar to lambdas concept for coroutines, but not just a lambdas which are coroutines.
I mean something like `async` blocks in rust, which result is directly a coroutine object and not a functional object which returns a coroutine object.
Two levels of indirection are likely unpractical and perhaps unachievable because of Ü limitations for structs with references inside.

Also it would be nice to have possibility to cast lambdas without captures into function pointers.
But right now it is not possible to do this just by performing binary cast, because of different internal LLVM function signatures.
